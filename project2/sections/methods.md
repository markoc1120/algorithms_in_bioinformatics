## Methods

We have implemented global alignment algorithms with the possibility of using either linear or affine gap costs. Speaking of the linear gap cost algorithm, the implementation itself can be find in `scripts/global_linear.py`. There are two main differences between our algorithm and the one we were talking during the class. One of them is that we penalize mismatch and gap costs with higher score, therefore in the cost calculation we minimize the optimal cost rather than maximizing it as we have done in the class. The other difference is in the backtracking algorithm, where we not only retrieve one optimal alignment but rather all of the optimal alignment, thus it takes much more time for our backtracking algorithm to run. Some comments among the algorithms can be found to make it easier to understand.

Turning to the affine gap cost algorithm, the cost calculation part of the algorithm works almost exactly the same way we have discussed in the class, besides the S matrixes, where we store our optimal alignment scores, we introduced two new matrixes, namely D for tracking the deletions and I for the insertions. Instead of using an iterative backtracking algorithm for this we have used a recursive one, which also find all the optimal alignments as previously mentioned.

Although our backtracking algorithms have higher time complexities [$O(2^{n})$] than just getting a single optimal alignment [$O(n)$], the cost calculation parts are [$O(nm)$] for both time and space complexity for linear and affine gap costs as well. [n represents length of sequence1 and m represents length of sequence2 and assuming n > m]

Regarding the usage, at first you should create a conda environment with the following command while being in the main folder (project2): `conda env create -f environment.yml`, which will create a conda environment with the proper required packages. After running this command you can activate the newly created environment with the following: `conda activate alignment_plus`. Now you can simply
ask for help by running: `alignment_plus --help`. `alignment_plus --seq1 gcct --seq2 gggc --gap-model affine` is an example of running our program, --seq1 and --seq2 are required arguments, which can either be the sequence itself or a path to the sequence. This will write the analysis to the stdin of your shell, with a random optimal alignment, in case you define `--output-path` argument then all the optimal alignments are saved to the specified path as fasta file, e.g.: `alignment_plus --seq1 gcct --seq2 gggc --gap-model affine --output-path results/alignments/results.fasta`. The parameters can be modified in the `parameters/` folder, _score_matrix.csv_, and _gapextend_ are intuitive, _gapopen_ is the gap cost for the linear cost algorithm and also the gap opening cost for the affine.

This report itself can be regenerated by `snakemake --cores all`. You can also change the sequences you want to analyze by changing the sequences found in `data/sequences.fasta`.
